/*
* Copyright 2018 The OpenWallet Authors
* This file is part of the OpenWallet library.
*
* The OpenWallet library is free software: you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* The OpenWallet library is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU Lesser General Public License for more details.
 */

// Generated by hand-operated
package tron

import (
	"bytes"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"log"
	"time"

	"github.com/blocktree/go-OWCBasedFuncs/addressEncoder"
	"github.com/blocktree/go-OWCrypt"

	// "github.com/gogo/protobuf/proto"
	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/ptypes/any"
	"github.com/shengdoushi/base58"
	"github.com/tronprotocol/grpc-gateway/core"
)

func GetTxHash(tx *core.Transaction) (txHash []byte, err error) {

	txRaw, err := proto.Marshal(tx.GetRawData())
	if err != nil {
		return nil, err
	}
	txHash = owcrypt.Hash(txRaw, 0, owcrypt.HASH_ALG_SHA256)
	return txHash, err
}

// Done
// Function: Create a transaction
//
// public static Transaction setReference(Transaction transaction, Block newestBlock) {
// 	long blockHeight = newestBlock.getBlockHeader().getRawData().getNumber();
// 	byte[] blockHash = getBlockHash(newestBlock).getBytes();
// 	byte[] refBlockNum = ByteArray.fromLong(blockHeight);
// 	Transaction.raw rawData = transaction.getRawData().toBuilder()
// 	    .setRefBlockHash(ByteString.copyFrom(ByteArray.subArray(blockHash, 8, 16)))
// 	    .setRefBlockBytes(ByteString.copyFrom(ByteArray.subArray(refBlockNum, 6, 8)))
// 	    .build();
// 	return transaction.toBuilder().setRawData(rawData).build();
// }
//
// public static Transaction createTransaction(byte[] from, byte[] to, long amount) {
// 	Transaction.Builder transactionBuilder = Transaction.newBuilder();
// 	Block newestBlock = WalletClient.getBlock(-1);
//
// 	Transaction.Contract.Builder contractBuilder = Transaction.Contract.newBuilder();
// 	Contract.TransferContract.Builder transferContractBuilder = Contract.TransferContract.newBuilder();
//
// 	transferContractBuilder.setAmount(amount);
// 	ByteString bsTo = ByteString.copyFrom(to);
// 	ByteString bsOwner = ByteString.copyFrom(from);
// 	transferContractBuilder.setToAddress(bsTo);
// 	transferContractBuilder.setOwnerAddress(bsOwner);
//
// 	try {
// 	  Any any = Any.pack(transferContractBuilder.build());
// 	  contractBuilder.setParameter(any);
// 	} catch (Exception e) {
// 	  return null;
// 	}
// 	contractBuilder.setType(Transaction.Contract.ContractType.TransferContract);
//
// 	transactionBuilder.getRawDataBuilder().addContract(contractBuilder)
// 	    .setTimestamp(System.currentTimeMillis())//timestamp should be in millisecond format
// 	    .setExpiration(newestBlock.getBlockHeader().getRawData().getTimestamp() + 10 * 60 * 60 * 1000);//exchange can set Expiration by needs
// 	Transaction transaction = transactionBuilder.build();
// 	Transaction refTransaction = setReference(transaction, newestBlock);
// 	return refTransaction;
// }
func (wm *WalletManager) CreateTransactionRef(to_address, owner_address string, amount int64) (txRawHex string, err error) {

	// addressEncoder.AddressDecode return 20 bytes of the center of Address
	to_address_bytes, err := addressEncoder.AddressDecode(to_address, addressEncoder.TRON_mainnetAddress)
	if err != nil {
		return "", err
	} else {
		to_address_bytes = append([]byte{0x41}, to_address_bytes...)
		to_address_bytes, err = base58.Decode(to_address, base58.BitcoinAlphabet)
		to_address_bytes = to_address_bytes[:len(to_address_bytes)-4]
	}

	owner_address_bytes, err := addressEncoder.AddressDecode(owner_address, addressEncoder.TRON_mainnetAddress)
	if err != nil {
		return "", err
	} else {
		owner_address_bytes = append([]byte{0x41}, owner_address_bytes...)
		owner_address_bytes, err = base58.Decode(owner_address, base58.BitcoinAlphabet)
		// fmt.Println("XXX = ", owner_address_bytes)
		owner_address_bytes = owner_address_bytes[:len(owner_address_bytes)-4]
	}
	fmt.Println("to_address = ", hex.EncodeToString(to_address_bytes))
	fmt.Println("owner_addr = ", hex.EncodeToString(owner_address_bytes))

	// --------------------- Generate TX Contract ------------------------

	tc := &core.TransferContract{
		OwnerAddress: to_address_bytes,
		ToAddress:    owner_address_bytes,
		Amount:       amount,
	}

	tcRaw, err := proto.Marshal(tc)
	if err != nil {
		return "", err
	}

	txContact := &core.Transaction_Contract{
		Type:         core.Transaction_Contract_TransferAssetContract,
		Parameter:    &any.Any{Value: tcRaw},
		Provider:     nil,
		ContractName: nil,
	}

	// ----------------------- Get Reference Block ----------------------
	block, err := tw.GetNowBlock()
	if err != nil {
		return txRawHex, err
	}
	block.BlockHeader.RawData.GetParentHash()
	bkHeader := block.GetBlockHeader().GetRawData()
	blockHight := bkHeader.GetNumber()
	var buffer bytes.Buffer
	if err := binary.Write(&buffer, binary.BigEndian, blockHight); err != nil {
		return "", err
	}
	blockHash, err := proto.Marshal(block.GetBlockHeader())
	if err != nil {
		return txRawHex, err
	}
	refBlockBytes := buffer.Bytes()[6:8]
	refBlockHash := blockHash[8:16]
	// refBlockNum := blockHight

	// -------------------- Set timestamp --------------------
	/*
		RFC 3339 date strings
		Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.

		    long millis = System.currentTimeMillis();

		    Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
			  .setNanos((int) ((millis % 1000) * 1000000)).build();
	*/
	timestamp := time.Now().UnixNano() // <int64

	// -------------------- Create Traction --------------------
	txRaw := &core.TransactionRaw{
		RefBlockBytes: refBlockBytes,
		RefBlockHash:  refBlockHash,
		RefBlockNum:   int64(0),
		Contract:      []*core.Transaction_Contract{txContact},
		Timestamp:     timestamp, //  timestamp,
		Expiration:    timestamp + 10*60*60*1000,
	}
	tx := &core.Transaction{
		RawData: txRaw,
		// Signature: nil,
		// Ret:       nil,
	}
	// fmt.Println("tx = ", tx)

	// -------------------- TX Encoding --------------------
	if x, err := proto.Marshal(tx); err != nil {
		return "", err
	} else {
		txRawHex = hex.EncodeToString(x)
	}

	return txRawHex, nil
}

// public static Transaction sign(Transaction transaction, ECKey myKey) {
// 	Transaction.Builder transactionBuilderSigned = transaction.toBuilder();
//
// 	byte[] hash = Sha256Hash.hash(transaction.getRawData().toByteArray());
//
// 	List<Contract> listContract = transaction.getRawData().getContractList();
//
// 	for (int i = 0; i < listContract.size(); i++) {
// 	  ECDSASignature signature = myKey.sign(hash);
// 	  ByteString bsSign = ByteString.copyFrom(signature.toByteArray());
// 	  transactionBuilderSigned.addSignature(bsSign);  //Each contract may be signed with a different private key in the future.
// 	}
//
// 	transaction = transactionBuilderSigned.build();
//
// 	return transaction;
// }
func (wm *WalletManager) GetTransactionSignRef(txRawhex string, privateKey string) (signedTxRaw string, err error) {

	tx := &core.Transaction{}
	if txRawBts, err := hex.DecodeString(txRawhex); err != nil {
		return signedTxRaw, err
	} else {
		if err := proto.Unmarshal(txRawBts, tx); err != nil {
			return signedTxRaw, err
		}
	}

	txHash, err := GetTxHash(tx)
	if err != nil {
		return signedTxRaw, err
	}
	fmt.Println("Tx Hash = ", hex.EncodeToString(txHash))

	pk, err := hex.DecodeString(privateKey)
	if err != nil {
		return signedTxRaw, err
	}

	for i, _ := range tx.GetRawData().GetContract() {

		// sign, ret := owcrypt.Signature(privateKey, nil, 0, txHash, uint16(len(txHash)), owcrypt.ECC_CURVE_SECP256K1)
		// fmt.Println("Signature = ", hex.EncodeToString(sign))

		sign, ret := owcrypt.ETHsignature(pk, txHash)
		if ret != owcrypt.SUCCESS {
			err := errors.New(fmt.Sprintf("Signature[%d] faild!", i))
			log.Println(err)
			return signedTxRaw, err
		}
		tx.Signature = append(tx.Signature, sign)
		fmt.Println("Signature = ", hex.EncodeToString(sign))
	}
	fmt.Println("TX[Signed] = \n\t", tx)

	if x, err := proto.Marshal(tx); err != nil {
		return signedTxRaw, err
	} else {
		signedTxRaw = hex.EncodeToString(x)
	}

	return signedTxRaw, nil

}

//   /*
//    * 1. check hash
//    * 2. check double spent
//    * 3. check sign
//    * 4. check balance
//    */
//  public static boolean validTransaction(Transaction signedTransaction) {
// 	assert (signedTransaction.getSignatureCount() == signedTransaction.getRawData().getContractCount());
//
// 	List<Transaction.Contract> listContract = signedTransaction.getRawData().getContractList();
//
// 	byte[] hash = Sha256Hash.hash(signedTransaction.getRawData().toByteArray());
//
// 	int count = signedTransaction.getSignatureCount();
// 	if (count == 0) {
// 	  return false;
// 	}
//
// 	for (int i = 0; i < count; ++i) {
// 	  try {
// 	    Transaction.Contract contract = listContract.get(i);
//
// 	    byte[] owner = getOwner(contract);
// 	    byte[] address = ECKey.signatureToAddress(hash, getBase64FromByteString(signedTransaction.getSignature(i)));
// 	    if (!Arrays.equals(owner, address)) {
// 		return false;
// 	    }
//
// 	  } catch (SignatureException e) {
// 	    e.printStackTrace();
// 	    return false;
// 	  }
// 	}
// 	return true;
//  }
func (wm *WalletManager) ValidSignedTransactionRef(txHex string) error {

	tx := &core.Transaction{}
	if txBytes, err := hex.DecodeString(txHex); err != nil {
		return nil
	} else {
		if err := proto.Unmarshal(txBytes, tx); err != nil {
			return err
		}
	}

	// fmt.Println("Tx = ", tx)
	fmt.Println("Tx Rawdata->RefBlockBytes = ", hex.EncodeToString(tx.RawData.RefBlockBytes))
	fmt.Println("Tx Rawdata->RefBlockHash  = ", hex.EncodeToString(tx.RawData.RefBlockHash))
	fmt.Println("Tx Rawdata->RefBlockNum   = ", tx.RawData.RefBlockNum)
	fmt.Println("Tx Rawdata->Expiration = ", tx.RawData.Expiration)
	fmt.Println("Tx Rawdata->Timestamp  = ", tx.RawData.Timestamp)
	fmt.Println("Tx Signature = ", hex.EncodeToString(tx.Signature[0]))
	// for _, sign := range tx.Signature {
	// 	fmt.Println("Signature = ", hex.EncodeToString(sign))
	// }
	fmt.Println("")

	if len(tx.GetSignature()) != len(tx.GetRawData().GetContract()) {
		err := errors.New("ValidSignedTransactionRef faild: no signature found!")
		log.Println(err)
		return err
	}

	listContracts := tx.RawData.GetContract()
	countSignature := len(tx.Signature)

	txHash, err := GetTxHash(tx)
	if err != nil {
		return err
	}

	// txRaw, err := proto.Marshal(tx.GetRawData())
	// if err != nil {
	// 	return err
	// }
	// fmt.Println("Tx countSign: ", countSignature)
	// fmt.Println("Tx txRaw: ", hex.EncodeToString(txRaw))

	if countSignature == 0 {
		return errors.New("No signature found!")
	}

	for i := 0; i < countSignature; i++ {
		contract := listContracts[i]

		// Get the instance of TransferContract to get Owner Address for validate signature
		tc := &core.TransferContract{}
		proto.Unmarshal(contract.Parameter.GetValue(), tc)
		owner_address_hex := hex.EncodeToString(tc.GetOwnerAddress())

		pkBytes, ret := owcrypt.RecoverPubkey(tx.Signature[i], txHash, owcrypt.ECC_CURVE_SECP256K1|owcrypt.HASH_OUTSIDE_FLAG)
		if ret != owcrypt.SUCCESS {
			err := errors.New("ValidSignedTransactionRef faild: owcryt.RecoverPubkey return err!")
			log.Println(err)
			return err
		}
		fmt.Println("  signature = ", hex.EncodeToString(tx.Signature[i]))
		fmt.Println("  Tx_txHash = ", hex.EncodeToString(txHash))
		fmt.Println("  publickey = ", hex.EncodeToString(pkBytes))

		sign_address_bytes, err := CreateAddressByPkRef(pkBytes)
		if err != nil {
			log.Println(err)
			return err
		}
		sign_address_bytes = sign_address_bytes[:len(sign_address_bytes)-4]
		sign_address_hex := hex.EncodeToString(sign_address_bytes)

		fmt.Println("  owner_address = ", owner_address_hex)
		fmt.Println("  pk_to_address = ", sign_address_hex)

		// Check whether the address is equal between signature generating and contract owner pointed
		if sign_address_hex != owner_address_hex {
			return errors.New("Validate failed, signed address is not the owner address!")
		}
	}

	return nil
}

func (wm *WalletManager) BroadcastTransactionRef(signature, txID, raw_data string) error {

	return nil
}
