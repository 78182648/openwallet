/*
* Copyright 2018 The OpenWallet Authors
* This file is part of the OpenWallet library.
*
* The OpenWallet library is free software: you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* The OpenWallet library is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU Lesser General Public License for more details.
 */

// Generated by hand-operated
package tron

import (
	"encoding/base64"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"log"
	"time"

	"github.com/blocktree/go-OWCBasedFuncs/addressEncoder"
	"github.com/blocktree/go-OWCrypt"

	// "github.com/gogo/protobuf/proto"
	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/ptypes/any"
	"github.com/tronprotocol/grpc-gateway/core"
)

var (
	b38 string = "0a650a200a02c51c2208f9ba51105d061ce540f8b1c380e22c5a02120070f9e5bf80e22c124149d63f0c407365a820d0bcc4c6225ec62f1a61a1fb351a0c55aa3a612d6651d349f47ce11780d53f50344286e4b358d32f13f4b45d7c073c8fae453d1ed52e54010a650a200a02c51c2208f9ba51105d061ce540f8b1c380e22c5a02120070a8e0bf80e22c12415e6975d4ee1f3100d9889e74894348fe53e43cb4eb2545d336423bae82ba68fe79c7942217d6d6ae6009aa32c8507ca697077fb12bd36c82f5a54a9351292fbf010a600a190a02c51b220868393dc9c231c07d40c0edd180e22c5a02120012430b1c6224e61b43fc36b0ebd43be7a437c64c9093c9425605029d186e240dc5eb0259fc158d4590e7ab9a1393808ee92a46a4a0e07b18a296555446f43de9f2f80190000a650a200a02c51c2208f9ba51105d061ce540f884d280e22c5a02120070c2f8bf80e22c124117f4f69b069d1eb7632813c2d90cbfae0b13f7bfd9a8f789b3346e14415fc6a566e5989ef6de9394e515d6d29d326ec19e689b234829ed01973bf46752f40c68010a650a200a02c51c2208f9ba51105d061ce540f8b1c380e22c5a02120070e4ebbf80e22c1241eb624fd75e061d3ddb578e8bd4fc17be21294aab2c7454095d4e73a56e7cf31d6d663b4fc2a93308c0f20f74a676980d8a9d6b035e1ba5a124c3179afd277ec5010a650a200a02c51c2208f9ba51105d061ce540f8b1c380e22c5a021200708debbf80e22c12419eb6d3aaaaa5159e285908b59fbcb10bd8241e97595a7f763223f163402542010e0f14eb6b91f566ba1a24f93ee7cb1999be561621cf859fe7e1c3b93b92d966010a5e0a190a02c51c2208f9ba51105d061ce540f884d280e22c5a021200124154ef2366c280f77b76c1299ed0cf3cb019ef1e0a62cd7e5430b2d759fe6593fb644cc770cc8438f4a041a8f929da00c01abb9c5a152925c583db4e9622a35e7d000a650a200a02c51c2208f9ba51105d061ce540f8b1c380e22c5a0212007095edbf80e22c1241f6bef61c8ee7f0c46039946c04aabae0df85fc0d9a09d2b8519145e6e67cbdfc315ef20cb4cbb85f26b8d379ce5f1d0b3647615482dea967840b8bd0abe32831000a650a200a02c51c2208f9ba51105d061ce540f8b1c380e22c5a02120070eeecbf80e22c1241afee5862fc9f4448861372e2d3c6cbfcd264bc6dc5c96cedfe7ec531b905979b2f580f8c5de658d839de97794d6420a40ce930173ac637877676c4705f480be5010a650a200a02c51c2208f9ba51105d061ce540f8b1c380e22c5a02120070ecf1bf80e22c124141446c60293778f96b9237b4f85bd35bfa982656d89b5c2a17a2bfa2b8ea47db5f4b560e2df4856df3e5b1e3951156679c0eb19e851c20fe55b6d2a582ff9641010a650a200a02c51c2208f9ba51105d061ce540f8b1c380e22c5a02120070b2f2bf80e22c1241b38b6c8f6aa8213e3e2e95d3eb8ce49e04748aa6f42d388dbfa353073598352b74a32f85be0df7a4917225a894e9fdcb4a36ee36e9a6cae71e78931f5c864b83010a650a200a02c51d22082e0556507b18837240b09cd280e22c5a02120070dc80c080e22c124115245778a37eac1a4018e43024493a2cf633dd4558e16c2b4c6f95472aad779c636be54425fe3080f63383d9617a730920e9a41ffa9e8d09fc29b3e87811daa8010a650a200a02c51d22082e0556507b18837240b0c9c380e22c5a0212007097fdbf80e22c1241fc77ff01a8546e3b2eafe52cf87f8940773d4a1951b9d698dd0cb09033981dc5348bd81be00da0230d865537a582ed2668a7fd2aa85cc419a6c3dfaf750adfc5000a5e0a190a02c51d22082e0556507b18837240b09cd280e22c5a02120012410d6bb59974dad960c2209fce2e1b201913d6bffb7a8aac04786816988953e845ccdd173926a542b4175f7b68404a4ac24b1f23b9772be681bcc467aeac084328010a650a200a02c51c2208f9ba51105d061ce540f8b1c380e22c5a02120070e5f8bf80e22c1241cff7a3a6a19c1ee41a5eaf8f4db829b56b3dd81ebe01be486fee4e32635f0f8434217e397aaeda8516a93e08b7396b9d8a2452b9472feb3d162d8208b676c5810112ac010a6708888cc080e22c12209464bcb21dd0d288118e77987f3d0035648cf7d0169a0d378e09427d05b9db571a20000000000029c51d2e0556507b1883725c3a25ab962178b95f60892c6021f109389e8aa7014a1541b3eec71481e8864f0fc1f601b836b74c4054828712419ec71c2a3a1e30f9a144a0262322edcd8a63b9de36df9916247fa31d19148cf611467bb291a189d28b00cc679df5688cdf749e53c171b1525f2a230c820fb57000"
	b39 string = "0a650a200a02c51d22082e0556507b18837240b09cd280e22c5a02120070f688c080e22c1241fab2348d6ae9ea047419d0b89211f50ec4b21c8801a426af2492411cd09257186086c0ce73d0b39e1a2f09877b98177df2c81ceb9c3c81a08ce2de9870070102010a650a200a02c51c2208f9ba51105d061ce540f8b1c380e22c5a02120070d0f9bf80e22c1241d5da43292313c3dabc47f89fd2e4e1cb7d755e3db9ea8362088f544fdba1975c542663a5fe12653ee51914e903064f46bc74a283b6d283ae4a5a50f45bdebb17000a650a200a02c51d22082e0556507b18837240b0c9c380e22c5a0212007088fcbf80e22c124190ab50de20bc2baba5dc618adff6e3271f28933b0b32bc711f4fa9497d5a721962fd5863a85e352291dcd05e0388076d55093b561591e94a41ab56f3a5cee005010a650a200a02c51d22082e0556507b18837240b0c9c380e22c5a021200709cfabf80e22c12416dd17a7e0ec777280ce0b4275fcacf72814bdd9253c896abe39836848ad9362b0b58b266e1f73fdae855472d19904c7dc3bdc44462d606f059dda75f618cf00c010a650a200a02c51d22082e0556507b18837240b0c9c380e22c5a02120070daffbf80e22c124180f1854c30d358e9d626f6baa6f95a68768bc423e35e6b858fa6c63eba5e312c3d641836e6287722436908f734fc9507a89355a27532ac583e845a3e33c7fe91010a650a200a02c51d22082e0556507b18837240b0c9c380e22c5a02120070adfebf80e22c1241b51f31431ddf61f9cdd4fa4ecc1a54438616473d8731443e050463d97c31549270dc999d59db6ab8f83971d235d90c0608a209ccd62edcda4f8666a98e4f29b1010a650a200a02c51d22082e0556507b18837240b0c9c380e22c5a02120070db8cc080e22c12412c7c62f2f0f98e2944ffd0598a84d9fa38389d33578954e9175ac35e1d8aaf753432f908b7c23430c4e3e3941626673a7cfac8e95f08ca99d8e07de9147081a8010a5e0a190a02c51e2208c59c4a6413879cf240e8b3d280e22c5a02120012414693accb2ea950e22b8c2f163bcc69128379427f82deafcdbb3c611a047b12170c2e59de4229adc9d7aef213ebe6a83bc7e53d0d63a34efd34f178d439250e51000a650a200a02c51d22082e0556507b18837240b0c9c380e22c5a02120070d887c080e22c1241dc0cd4ace6e40e6a4273f5d567c1ef95be4447593fbd2901951068aa689c6f020ee229ebb22bd8136b31bea40f50d131690ad3bff4eda7ae2453048e5dd16dfa010a650a200a02c51d22082e0556507b18837240b0c9c380e22c5a021200708c89c080e22c1241c656a65f74f1d8e062299bfc4404935c5d8b66d2d48a8d6adc4e76e448d7c13a29ce6aeb151f8dc5ae370ba094cfbbb0c0a608a84712817f667c461e6c952fcf000a650a200a02c51e2208c59c4a6413879cf240e8b3d280e22c5a021200708491c080e22c1241075c4c55a687af5618c50b7d916d7cec146eda34294437d89725fd64ee3c4d4373ddcae2c175d5fece28f9b666015405b02195d9cd65380c9bd04434da0cfa51010a650a200a02c51d22082e0556507b18837240b0c9c380e22c5a02120070a58bc080e22c1241e3d7a7c128006cbbdabb9c5666012a6790a687a5998d98912b5b4a5d1c47bb747f15df279da828f08dc8459a3bdd78bbb379637ff64edfb46e0a3788fd530a55000a650a200a02c51d22082e0556507b18837240b0c9c380e22c5a02120070e68dc080e22c124199b686232ae3f880964f00bbe70381172bc0b74123c995108931ca002e62e2bf1bd059976e9837c4b354d8afea56a0d548a34bb643c3c08a7427044e75a0005d010a650a200a02c51d22082e0556507b18837240b0c9c380e22c5a02120070c88ac080e22c12412ad8f52e85d859fa3c099c11f2039e76e6c2829dbe9db470e62586bd8d35c1fc6ce115f47533973824f5a2531fc752a41877ad39779bf53a48c5077b6847710d010a650a200a02c51e2208c59c4a6413879cf240e8e0c380e22c5a02120070919cc080e22c124167d98fc07ab02bbecfd7f5455e4528c026511713ca438c1ed9d9f23e361a1d3343cc7b4c796c3f01ac31caa00d445d717897e02fdb1ad8918790da989b4bae9c010a650a200a02c51d22082e0556507b18837240b0c9c380e22c5a02120070d68cc080e22c12412508d49598b16b8ff3fc97df4db456d7ca26090619764cf73752c3092034db7e6d932f63393f80112eccf0bceca16ac9cfd15f49af287d2253272fa819d77b08010a650a200a02c51e2208c59c4a6413879cf240e8b3d280e22c5a02120070fc9ec080e22c12410f7b188f346b81869246e31ed003b32920858f53851fe6a489bb9508393d7ac169e83366f56a90eff700020a14f724538f670d3a64610b9f7c1dceb284a954600012ac010a6708c0a3c080e22c12205da8a8296aa9b1c39de45d913a345931d7ed7a6befa539c97daf3661e576d1cd1a20000000000029c51ec59c4a6413879cf27f8b2dd1d51234125c53094e4109b09a389f8aa7014a15414d1ef8673f916debb7e2515a8f3ecaf2611034aa1241af691e8d6e69905302c9295cd999a4e1da8b7da277b1ad3594d0ace864dd9abd050ec5bad6793af375d62b839f4adc7c7caba7b2ac5672f11823012d16f864e400"
	b40 string = "0a650a200a02c51e2208c59c4a6413879cf240e8e0c380e22c5a02120070cd94c080e22c1241fbee850c56cb8e042ff70a8e5c26f220ef9997242485e1ce3d60386e502d66ff771579f9d9236f385b22d2f4b91bac96a01152aa01bad7be68120db2f31d3dc5010a650a200a02c51e2208c59c4a6413879cf240e8b3d280e22c5a0212007084a3c080e22c1241604a92a2f33335ee3ad8865b40debd61cda425dbc9a84668a7b3fa10b9ac4c722c482ae826a1f8ef7305f93ecd6f02aa7f6056b200dddef3b86608b0aa2011af000a650a200a02c51e2208c59c4a6413879cf240e8e0c380e22c5a02120070bd95c080e22c1241406e12e3a50cd44ab04b858f8be973120ad17bf3ce8a5331e7430ac91cfdaeb537a77b7a1a7f9ce180e074c524f48cf9829fecc8c47929719a1b2e8b00225f07010a650a200a02c51e2208c59c4a6413879cf240e8e0c380e22c5a02120070a89bc080e22c12414ea03416c5accabde51867c26b5da79ea3537d9c0b65d971289c05fbf69808591af153e9e2ba614e38e690e6408cade558e44cd966c5532a7c6f5860483fd9dd010a650a200a02c51e2208c59c4a6413879cf240e8e0c380e22c5a02120070c99bc080e22c1241fe107d59ea0ccf66656a3bd6ba4feccadfccafb67be6c7d651f926f685e59bde788c1edb49e970ea1cdbd2cbd4b5e988f675e05706bf62e4362d972ee1a2c11a000a650a200a02c51e2208c59c4a6413879cf240e8e0c380e22c5a02120070f49cc080e22c124189da69da12b43c3bea45bb949ff3e1f5b2a454460b551aa6ae32fbe937a26cd96d619541d388a77eef60629dfe4307f16a5b6b01fd2a126b6e76803e8b60e86e010a650a200a02c51e2208c59c4a6413879cf240e8e0c380e22c5a021200709e9ec080e22c1241e39924d222328a3df30c61fb3d5c3f95985c628d436fbd874d858ca6fbf7a601299573670f547f740119a96f74c04746f62a52dbf0ceb50dcfe28142e5b8422d000a650a200a02c51f22088140429b486b496d40a0cbd280e22c5a0212007090abc080e22c124183b3601947aa2b6981f580b785e1cee9818977e2ed6fcefdf52da178e6b5ec7c757dc83715bd2f713a759da1b11c49d4789c423b761c1f11d544578bf537af12000a650a200a02c51f22088140429b486b496d40a0f8c380e22c5a02120070c6abc080e22c1241c50f0e333f5a7f43518035fed2b9447ed3c44d9d27756010dd726561514d80ab5acb1b57a9bca3f20aed18ba704ca1abaccc80e8d51abbb98c561a2fc109c5d5010a650a200a02c51e2208c59c4a6413879cf240e8e0c380e22c5a02120070c4a2c080e22c1241dadad9b0b23288265c0823bf9efea2c1172f1aee7f3c7500da9433f4091cf3f42703903066d94a44a54b6dbf2532e1390b29b4aa47d3b9bbd180af689f695d5e010a650a200a02c51f22088140429b486b496d40a0cbd280e22c5a021200709db3c080e22c1241f7c1106dfeb87513c78e62a5f2f9343661914035f41e32cd09f14af0b82644775b070b26216d0d55f4c362997c1e869cd88ead72e135268d2409bd0fc177d130010a650a200a02c51e2208c59c4a6413879cf240e8e0c380e22c5a02120070efa1c080e22c12411c9d5d3838aeb416eedbea4719680042126cad2081c0505ab4b1334fea5ad2db144896320a80eca81766c6099040c01e1ff9ad0f79cdfbad8f2d341b241707dc010a650a200a02c51c2208f9ba51105d061ce540fd9dd9a9e22c5a02120070fde5bf80e22c12412a3c08d0d192a98e3aff6f3c521e313bbef1e4e009a37d7db3b6c35176411b8923a65ef7370a5295b1876ce0b8ae7afc27ece0420a70ba8f4b37bcdc90db5f890012ac010a6708f8bac080e22c12201b70128ccbaf4420f5ea21f983c10cbdf1f55100d92d68e04d817281ed0b71f61a20000000000029c51f8140429b486b496d4eca05a4b3ed470f9d0cab1d21f8a69938a08aa7014a1541d1dbde8b8f71b48655bec4f6bb532a0142b88bc01241605117b26a261d92faf28eec0000075ca334f209162c5aa91c9236671ce00e545185e9f9b3611e13c22560ff9989c1616b3a3e6b5f2685bbad18c467c08f722200"
)

func GetTxHash(tx *core.Transaction) (txHash []byte, err error) {

	txRaw, err := proto.Marshal(tx.GetRawData())
	if err != nil {
		return nil, err
	}
	txHash = owcrypt.Hash(txRaw, 0, owcrypt.HASH_ALG_SHA256)
	return txHash, err
}

// func GetBlockHash(block *core.Block) (blockHash []byte, err error) {
// 	blockHeaderRaw, err := proto.Marshal(block.GetBlockHeader().GetRawData())
// 	if err != nil {
// 		return nil, err
// 	}
// 	blockHashBytes := owcrypt.Hash(blockHeaderRaw, 0, owcrypt.HASH_ALG_SHA256)
// 	return blockHashBytes, nil
// }

func GetBlockHash(raw string) string {
	block := &core.Block{}
	x, _ := hex.DecodeString(raw)
	proto.Unmarshal(x, block)

	blockHeaderRaw, _ := proto.Marshal(block.GetBlockHeader().GetRawData())
	blockHashBytes := owcrypt.Hash(blockHeaderRaw, 0, owcrypt.HASH_ALG_SHA256)

	return hex.EncodeToString(blockHashBytes)
}
func GetParentHash(raw string) string {
	block := &core.Block{}
	x, _ := hex.DecodeString(raw)
	proto.Unmarshal(x, block)
	return hex.EncodeToString(block.GetBlockHeader().GetRawData().GetParentHash())
}

func Tmm() {
	for i, raw := range []string{b38, b39, b40} {
		fmt.Printf("H%d Phash=%+v\n", i, GetParentHash(raw))
		fmt.Println("")
		fmt.Printf("H%d Chash=%+v\n", i, GetBlockHash(raw))

	}

	// block39 := &core.Block{}
	// x1, _ := hex.DecodeString(b39)
	// proto.Unmarshal(x1, block39)
	// b38_hash_t := hex.EncodeToString(block39.GetBlockHeader().GetRawData().GetParentHash())
	// fmt.Println("True: ", b38_hash_t)

	// block38 := &core.Block{}
	// x2, _ := hex.DecodeString(b38)
	// proto.Unmarshal(x2, block38)
	// xx, _ := GetBlockHash(block38)
	// b38_hash_g := hex.EncodeToString(xx)
	// fmt.Println("Gene: ", b38_hash_g)
}

// Done
// Function: Create a transaction
//
// public static Transaction setReference(Transaction transaction, Block newestBlock) {
// 	long blockHeight = newestBlock.getBlockHeader().getRawData().getNumber();
// 	byte[] blockHash = getBlockHash(newestBlock).getBytes();
// 	byte[] refBlockNum = ByteArray.fromLong(blockHeight);
// 	Transaction.raw rawData = transaction.getRawData().toBuilder()
// 	    .setRefBlockHash(ByteString.copyFrom(ByteArray.subArray(blockHash, 8, 16)))
// 	    .setRefBlockBytes(ByteString.copyFrom(ByteArray.subArray(refBlockNum, 6, 8)))
// 	    .build();
// 	return transaction.toBuilder().setRawData(rawData).build();
// }
//
// public static Transaction createTransaction(byte[] from, byte[] to, long amount) {
// 	Transaction.Builder transactionBuilder = Transaction.newBuilder();
// 	Block newestBlock = WalletClient.getBlock(-1);
//
// 	Transaction.Contract.Builder contractBuilder = Transaction.Contract.newBuilder();
// 	Contract.TransferContract.Builder transferContractBuilder = Contract.TransferContract.newBuilder();
//
// 	transferContractBuilder.setAmount(amount);
// 	ByteString bsTo = ByteString.copyFrom(to);
// 	ByteString bsOwner = ByteString.copyFrom(from);
// 	transferContractBuilder.setToAddress(bsTo);
// 	transferContractBuilder.setOwnerAddress(bsOwner);
//
// 	try {
// 	  Any any = Any.pack(transferContractBuilder.build());
// 	  contractBuilder.setParameter(any);
// 	} catch (Exception e) {
// 	  return null;
// 	}
// 	contractBuilder.setType(Transaction.Contract.ContractType.TransferContract);
//
// 	transactionBuilder.getRawDataBuilder().addContract(contractBuilder)
// 	    .setTimestamp(System.currentTimeMillis())//timestamp should be in millisecond format
// 	    .setExpiration(newestBlock.getBlockHeader().getRawData().getTimestamp() + 10 * 60 * 60 * 1000);//exchange can set Expiration by needs
// 	Transaction transaction = transactionBuilder.build();
// 	Transaction refTransaction = setReference(transaction, newestBlock);
// 	return refTransaction;
// }
func (wm *WalletManager) CreateTransactionRef(to_address, owner_address string, amount int64) (txRawHex string, err error) {

	// Tmm()
	// return "", nil

	// addressEncoder.AddressDecode return 20 bytes of the center of Address
	to_address_bytes, err := addressEncoder.AddressDecode(to_address, addressEncoder.TRON_mainnetAddress)
	if err != nil {
		return "", err
	} else {
		to_address_bytes = append([]byte{0x41}, to_address_bytes...)

		// to_address_bytes, err = base58.Decode(to_address, base58.BitcoinAlphabet)
		// to_address_bytes = to_address_bytes[:len(to_address_bytes)-4]
	}

	owner_address_bytes, err := addressEncoder.AddressDecode(owner_address, addressEncoder.TRON_mainnetAddress)
	if err != nil {
		return "", err
	} else {
		owner_address_bytes = append([]byte{0x41}, owner_address_bytes...)
	}
	// fmt.Println("to_address = ", hex.EncodeToString(to_address_bytes))
	// fmt.Println("owner_addr = ", hex.EncodeToString(owner_address_bytes))

	// --------------------- Generate TX Contract ------------------------

	tc := &core.TransferContract{
		OwnerAddress: owner_address_bytes,
		ToAddress:    to_address_bytes,
		Amount:       amount * 1000000,
	}

	tcRaw, err := proto.Marshal(tc)
	if err != nil {
		return "", err
	}

	txContact := &core.Transaction_Contract{
		Type:         core.Transaction_Contract_TransferContract,
		Parameter:    &any.Any{Value: tcRaw, TypeUrl: "type.googleapis.com/protocol.TransferContract"},
		Provider:     nil,
		ContractName: nil,
	}

	// ----------------------- Get Reference Block ----------------------
	block, err := tw.GetNowBlock()
	if err != nil {
		return txRawHex, err
	}

	blockHight := block.GetBlockHeader().GetRawData().GetNumber() - 1
	blockHightBytes := make([]byte, 8)
	binary.BigEndian.PutUint64(blockHightBytes, uint64(blockHight))
	refBlockBytes := blockHightBytes[6:8]

	blockHeaderRaw, err := proto.Marshal(block.GetBlockHeader().GetRawData())
	if err != nil {
		return "", err
	}
	blockHashBytes := owcrypt.Hash(blockHeaderRaw, 0, owcrypt.HASH_ALG_SHA256)
	refBlockHash := blockHashBytes[8:16]
	fmt.Println("@@@ = ", block.GetBlockHeader().GetRawData().GetParentHash())
	refBlockHash = block.GetBlockHeader().GetRawData().GetParentHash()[8:16]

	hh := hex.EncodeToString(block.GetBlockHeader().GetRawData().GetParentHash())[8:16]
	refBlockHash = []byte(base64.StdEncoding.EncodeToString([]byte(hh)))
	// refBlockHash = []byte(base64.StdEncoding.EncodeToString(refBlockHash))

	// // refBlockHash2 := []byte(base64.StdEncoding.EncodeToString(blockHashBytes))
	// // refBlockHash2 := []byte(base64.StdEncoding.EncodeToString([]byte(hex.EncodeToString(blockHashBytes)[8:16])))
	// fmt.Println("\tBlockHight Bytes: ", blockHightBytes, "Len: ", len(blockHightBytes))
	// fmt.Println("\tBlockHight Hex  : ", hex.EncodeToString(blockHightBytes), "Len: ", len(hex.EncodeToString(blockHightBytes)))
	// fmt.Println("\trefBlockBytes:    ", refBlockBytes, "Len: ", len(refBlockBytes))
	// fmt.Println("\trefBlockBytes Hex:", hex.EncodeToString(refBlockBytes), "Len: ", len(hex.EncodeToString(refBlockBytes)))
	// fmt.Println("")
	// // block.GetBlockHeader()
	// bparentHashBytes := block.GetBlockHeader().GetRawData().GetParentHash()
	// fmt.Println("\tBlock Prt Bytes: ", bparentHashBytes, "Len: ", len(bparentHashBytes))
	// fmt.Println("\tBlockHash Bytes: ", blockHashBytes, "Len: ", len(blockHashBytes))
	// fmt.Println("\tBlockHash Hex:   ", hex.EncodeToString(blockHashBytes), "Len: ", len(hex.EncodeToString(blockHashBytes)))
	// fmt.Println("\trefBlockHash:    ", refBlockHash, "Len: ", len(refBlockHash))
	// fmt.Println("\trefBlockHash Hex:", hex.EncodeToString(refBlockHash), "Len: ", len(hex.EncodeToString(refBlockHash)))
	// // fmt.Println("\trefBlockHash2:    ", refBlockHash2, "Len: ", len(refBlockHash2))
	// // fmt.Println("\trefBlockHash2 Hex:", hex.EncodeToString(refBlockHash2), "Len: ", len(hex.EncodeToString(refBlockHash2)))
	// // fmt.Println("\tBlockHash Hex:   ", hex.EncodeToString(blockHashBytes), "Len: ", len(blockHashBytes))
	// // fmt.Println("\tBlockHash refBlockBytes Hex: ", hex.EncodeToString(refBlockBytes))

	// -------------------- Set timestamp --------------------
	/*
		RFC 3339 date strings
		Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.

		    long millis = System.currentTimeMillis();

		    Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
			  .setNanos((int) ((millis % 1000) * 1000000)).build();
	*/
	timestamp := time.Now().UnixNano() / 1000000 // <int64

	// -------------------- Create Traction --------------------
	txRaw := &core.TransactionRaw{
		RefBlockBytes: refBlockBytes,
		RefBlockHash:  refBlockHash,
		// RefBlockNum:   int64(0),
		Contract: []*core.Transaction_Contract{txContact},
		// Timestamp:     int64(0), //  timestamp,
		Expiration: timestamp + 10*60*60,
	}
	tx := &core.Transaction{
		RawData: txRaw,
		// Signature: nil,
		// Ret:       nil,
	}

	// -------------------- TX Encoding --------------------
	if x, err := proto.Marshal(tx); err != nil {
		return "", err
	} else {
		txRawHex = hex.EncodeToString(x)
	}

	return txRawHex, nil
}

// public static Transaction sign(Transaction transaction, ECKey myKey) {
// 	Transaction.Builder transactionBuilderSigned = transaction.toBuilder();
//
// 	byte[] hash = Sha256Hash.hash(transaction.getRawData().toByteArray());
//
// 	List<Contract> listContract = transaction.getRawData().getContractList();
//
// 	for (int i = 0; i < listContract.size(); i++) {
// 	  ECDSASignature signature = myKey.sign(hash);
// 	  ByteString bsSign = ByteString.copyFrom(signature.toByteArray());
// 	  transactionBuilderSigned.addSignature(bsSign);  //Each contract may be signed with a different private key in the future.
// 	}
//
// 	transaction = transactionBuilderSigned.build();
//
// 	return transaction;
// }
func (wm *WalletManager) SignTransactionRef(txRawhex string, privateKey string) (signedTxRaw string, err error) {

	tx := &core.Transaction{}
	if txRawBts, err := hex.DecodeString(txRawhex); err != nil {
		return signedTxRaw, err
	} else {
		if err := proto.Unmarshal(txRawBts, tx); err != nil {
			return signedTxRaw, err
		}
	}
	fmt.Println("tx = ", tx)
	tx.GetRawData().GetRefBlockBytes()

	txHash, err := GetTxHash(tx)
	if err != nil {
		return signedTxRaw, err
	}

	pk, err := hex.DecodeString(privateKey)
	if err != nil {
		return signedTxRaw, err
	}

	for i, _ := range tx.GetRawData().GetContract() {

		// sign, ret := owcrypt.Signature(privateKey, nil, 0, txHash, uint16(len(txHash)), owcrypt.ECC_CURVE_SECP256K1)
		sign, ret := owcrypt.Tron_signature(pk, txHash)
		if ret != owcrypt.SUCCESS {
			err := errors.New(fmt.Sprintf("Signature[%d] faild!", i))
			log.Println(err)
			return signedTxRaw, err
		}
		tx.Signature = append(tx.Signature, sign)
	}

	if x, err := proto.Marshal(tx); err != nil {
		return signedTxRaw, err
	} else {
		signedTxRaw = hex.EncodeToString(x)
	}

	return signedTxRaw, nil

}

//   /*
//    * 1. check hash
//    * 2. check double spent
//    * 3. check sign
//    * 4. check balance
//    */
//  public static boolean validTransaction(Transaction signedTransaction) {
// 	assert (signedTransaction.getSignatureCount() == signedTransaction.getRawData().getContractCount());
//
// 	List<Transaction.Contract> listContract = signedTransaction.getRawData().getContractList();
//
// 	byte[] hash = Sha256Hash.hash(signedTransaction.getRawData().toByteArray());
//
// 	int count = signedTransaction.getSignatureCount();
// 	if (count == 0) {
// 	  return false;
// 	}
//
// 	for (int i = 0; i < count; ++i) {
// 	  try {
// 	    Transaction.Contract contract = listContract.get(i);
//
// 	    byte[] owner = getOwner(contract);
// 	    byte[] address = ECKey.signatureToAddress(hash, getBase64FromByteString(signedTransaction.getSignature(i)));
// 	    if (!Arrays.equals(owner, address)) {
// 		return false;
// 	    }
//
// 	  } catch (SignatureException e) {
// 	    e.printStackTrace();
// 	    return false;
// 	  }
// 	}
// 	return true;
//  }
func (wm *WalletManager) ValidSignedTransactionRef(txHex string) error {

	tx := &core.Transaction{}
	if txBytes, err := hex.DecodeString(txHex); err != nil {
		return nil
	} else {
		if err := proto.Unmarshal(txBytes, tx); err != nil {
			return err
		}
	}

	if len(tx.GetSignature()) != len(tx.GetRawData().GetContract()) {
		err := errors.New("ValidSignedTransactionRef faild: no signature found!")
		log.Println(err)
		return err
	}

	listContracts := tx.RawData.GetContract()
	countSignature := len(tx.Signature)

	txHash, err := GetTxHash(tx)
	if err != nil {
		return err
	}

	if countSignature == 0 {
		return errors.New("No signature found!")
	}

	for i := 0; i < countSignature; i++ {
		contract := listContracts[i]

		// Get the instance of TransferContract to get Owner Address for validate signature
		tc := &core.TransferContract{}
		if err := proto.Unmarshal(contract.Parameter.GetValue(), tc); err != nil {
			return err
		}

		owner_address_hex := hex.EncodeToString(tc.GetOwnerAddress())

		// pkBytes, ret := owcrypt.RecoverPubkey(tx.Signature[i], txHash, owcrypt.ECC_CURVE_SECP256K1|owcrypt.HASH_OUTSIDE_FLAG)
		pkBytes, ret := owcrypt.RecoverPubkey(tx.Signature[i], txHash, owcrypt.ECC_CURVE_SECP256K1)
		if ret != owcrypt.SUCCESS {
			err := errors.New("ValidSignedTransactionRef faild: owcryt.RecoverPubkey return err!")
			log.Println(err)
			return err
		}
		// fmt.Println("  signature = ", hex.EncodeToString(tx.Signature[i]))
		// fmt.Println("  publickey = ", hex.EncodeToString(pkBytes))
		// fmt.Println("  Tx_txHash = ", hex.EncodeToString(txHash))

		pkgen_address_bytes, err := createAddressByPkRef(pkBytes)
		if err != nil {
			log.Println(err)
			return err
		}
		pkgen_address_hex := hex.EncodeToString(pkgen_address_bytes[:len(pkgen_address_bytes)-4])

		// fmt.Println("")
		// fmt.Println("  owner_address = ", owner_address_hex)
		// fmt.Println("  pk_to_address = ", pkgen_address_hex)

		// Check whether the address is equal between signature generating and contract owner pointed
		if pkgen_address_hex != owner_address_hex {
			return errors.New("Validate failed, signed address is not the owner address!")
		}
	}

	return nil
}

func (wm *WalletManager) BroadcastTransactionRef(signature, txID, raw_data string) error {
	return nil
}

// ------------------------------------------------------------------------------------------------------
func debugPrintTx(txRawhex string) {

	tx := &core.Transaction{}
	if txRawBts, err := hex.DecodeString(txRawhex); err != nil {
		fmt.Println(err)
	} else {
		if err := proto.Unmarshal(txRawBts, tx); err != nil {
			fmt.Println(err)
		}
	}

	fmt.Println("vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv Print Test vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv")

	txHash, err := GetTxHash(tx)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println("Tx Hash = ", hex.EncodeToString(txHash))

	txRawD := tx.RawData
	txC := txRawD.GetContract()
	fmt.Println("txRawD.Contract = ")
	for _, c := range txC {
		fmt.Println("\tc.ContractName=", c.ContractName)
		fmt.Println("\tc.Provider   =", c.Provider)
		fmt.Println("\tc.Type       =", c.Type)
		fmt.Println("\tc.Parameter   =", c.Parameter)

		ts := &core.TransferContract{}
		proto.Unmarshal(c.Parameter.Value, ts)
		fmt.Println("\tts.OwnerAddress =", hex.EncodeToString(ts.OwnerAddress))
		fmt.Println("\tts.ToAddress =", hex.EncodeToString(ts.ToAddress))
		fmt.Println("\tts.Amount =", ts.Amount)
	}
	fmt.Println("txRawD.Data =  ", txRawD.Data)
	fmt.Println("txRawD.Auths =   ", txRawD.Auths)
	fmt.Println("txRawD.Scripts =   ", txRawD.Scripts)
	fmt.Println("txRawD.RefBlockBytes = ", hex.EncodeToString(txRawD.RefBlockBytes))
	fmt.Println("txRawD.RefBlockHash Bts = ", txRawD.RefBlockHash, "Len:", len(txRawD.RefBlockHash))
	fmt.Println("txRawD.RefBlockHash Hex = ", hex.EncodeToString(txRawD.RefBlockHash), "Len:", len(hex.EncodeToString(txRawD.RefBlockHash)))
	// dst := make([]byte, 32)
	// bs, err := base64.StdEncoding.Decode(dst, txRawD.RefBlockHash)
	// fmt.Println("txRawD.RefBlockHash base64Bytes = ", bs, "XX = ", dst)

	fmt.Println("")

	fmt.Println("txRawD.RefBlockNum =  ", txRawD.RefBlockNum)
	fmt.Println("txRawD.Expiration =  ", txRawD.Expiration)
	fmt.Println("txRawD.Timestamp =   ", txRawD.Timestamp)
	fmt.Println("tx.Signature[0]     = ", hex.EncodeToString(tx.Signature[0]))
	fmt.Println("tx.Ret          =     ", tx.Ret)

	fmt.Println("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Print Test ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ End")
}
