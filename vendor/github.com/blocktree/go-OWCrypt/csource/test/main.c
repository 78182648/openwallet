
#include <stdio.h>
#include "ecc_set.h"
#include  "keccak_256.h"
#include "string.h"
#include "hmac.h"
#include "hash_set.h"
#include <sys/time.h>
#include "sha3_256.h"
typedef struct
{
    unsigned char v[32];
    unsigned char k[32];
    int retry;
}HMAC_RFC6979;

int main()
{
#if 0
    uint8_t prikey[32]={0xE8,0xF0,0xE3,0x9A,0x27,0x5E,0x78,0xCF,0x72,0x79,0xD5,0x3A,0x1D,0x93,0x36,0xD9,0x77,0x55,0xD4,0x5B,0x71,0x02,0x4A,0xC5,0xB9,0x83,0xC4,0xC3,0xB7,0xD8,0x17,0x40};
    uint8_t pubkey[32];
//    uint8_t a[32]={0xED,0xB7,0xAA,0xDC,0x48,0x1E,0xD1,0x92,0x28,0x38,0x02,0xFF,0x71,0xE8,0xD0,0x35,0x3E,0x65,0xDB,0xDF,0x62,0x7B,0x29,0x70,0x1E,0x7C,0xF1,0xF8,0x4E,0x49,0x66,0x15};
//    uint8_t b[32]={0x9E,0x85,0x06,0xC2,0x23,0xE1,0x90,0x2B,0x19,0xA4,0x81,0xF8,0x07,0x90,0x50,0x03,0xED,0xB5,0xED,0xDA,0xE7,0x80,0xA7,0x13,0x02,0x29,0x1D,0x30,0x5A,0xA7,0xDF,0xDF};
//    uint8_t n[32]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,0xBF,0xD2,0x5E,0x8C,0xD0,0x36,0x41,0x41};
//    uint8_t c[32];
    struct timeval start, end;
    gettimeofday( &start, NULL );
    for (int i = 0; i<1000; i ++)
    {
        ECC_genPubkey(prikey,pubkey,ECC_CURVE_SECP256K1);
        //bignum_mod_mul(a, b, n, c);
        //bignum_mod_sub(a, b, n, c);
        //bignum_mod_inv(a, n, c);
    }
    gettimeofday( &end, NULL );
    int timeuse = (int)(1000000 * ( end.tv_sec - start.tv_sec ) + end.tv_usec - start.tv_usec);
    printf("time: %d us\n", timeuse);
    return 0;
    uint8_t a=0;
    uint16_t ret=0;
    uint32_t type = ECC_CURVE_ED25519;
    uint8_t prikey[32]={0xE8,0xF0,0xE3,0x9A,0x27,0x5E,0x78,0xCF,0x72,0x79,0xD5,0x3A,0x1D,0x93,0x36,0xD9,0x77,0x55,0xD4,0x5B,0x71,0x02,0x4A,0xC5,0xB9,0x83,0xC4,0xC3,0xB7,0xD8,0x17,0x40};
    uint8_t pubkey[32];
    //uint8_t ID[4]={0x11,0x22,0x33,0x44};
    //uint16_t IDlen=4;
    //uint8_t message[8]={0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc};
    //uint16_t message_len=8;
    //uint8_t sig[64];
    ECC_genPubkey(prikey, pubkey,  type);
     a++;
    type=ECC_CURVE_SECP256K1;
    ECC_sign(prikey,  ID,  IDlen,  message,  message_len,  sig, type);
    type = ECC_CURVE_ED25519;
    ret=ECC_verify(pubkey,  ID, IDlen,  message, message_len,  sig, type);
    if(ret==SUCCESS)
    {
        printf("ED25519 verify success\n");
    }
    else
    {
        printf("ED25519 verify fail\n");
    }
    uint8_t scalar[32]={0x9e,0xa1,0x9e,0x6e,0xc2,0x59,0xf7,0x85,0x4e,0xe4,0x1b,0x53,0x07,0xcf,0xc4,0xb8,0xf4,0x47,0x75,0x34,0x20,0x5e,0xc9,0x83,0xc4,0xd3,0xa9,0xb5,0x6c,0x0b,0x27,0x0c};
    uint8_t point[64];
    ECC_point_mul_baseG(scalar,  point,  ECC_CURVE_SECP256K1);
   
    uint8_t key[32]={0x02,0x83,0x84,0x5e,0x2b,0x12,0x0f,0xb5,0x96,0x4e,0x9f,0x48,0x7f,0x1c,0x87,0xe8,0x7a,0xe9,0xf7,0xd1,0x6f,0x0a,0x5e,0x77,0x13,0x14,0x7f,0x9e,0x84,0xf4,0xad,0x10,0x06};
    uint8_t data[38]={0x00,0x02,0x83,0x84,0x5e,0x2b,0x12,0x0f,0xb5,0x96,0x4e,0x9f,0x48,0x7f,0x1c,0x87,0xe8,0x7a,0xe9,0xf7,0xd1,0x6f,0x0a,0x5e,0x77,0x13,0x14,0x7f,0x9e,0x84,0xf4,0xad,0x10,0x06,0x00,0x00,0x00,0x00};
    uint8_t result[64];
    HMAC(key,32,data,38, result, HMAC_SM3_ALG);
  
    //uint8_t prikey[32]={0x9e,0xa1,0x9e,0x6e,0xc2,0x59,0xf7,0x85,0x4e,0xe4,0x1b,0x53,0x07,0xcf,0xc4,0xb8,0xf4,0x47,0x75,0x34,0x20,0x5e,0xc9,0x83,0xc4,0xd3,0xa9,0xb5,0x6c,0x0b,0x27,0x0c};
    uint8_t pubkey[33]={0x02,0x83,0x84,0x5E,0x2B,0x12,0x0F,0xB5,0x96,0x4E,0x9F,0x48,0x7F,0x1C,0x87,0xE8,0x7A,0xE9,0xF7,0xD1,0x6F,0x0A,0x5E,0x77,0x13,0x14,0x7F,0x9E,0x84,0xF4,0xAD,0x10,0x06};
    uint8_t digest[20];
    hash(pubkey, 33, digest, 20, HASH_ALG_HASH160);
    return 0;
#endif
   
#if 0
    uint16_t ret=0x1122;
    uint8_t prikey[32]={0xCE,0x85,0x29,0x74,0x01,0xED,0x27,0xCA,0x4B,0xD1,0x4F,0xFB,0xE6,0xF2,0x9B,0x31,0x6C,0x84,0x2E,0x42,0x7F,0x70,0x2B,0x5D,0x97,0x42,0x56,0x93,0x4B,0x20,0x54,0x88};
    uint8_t pubkey[64]={0xFA,0xE8,0xAD,0x07,0xA8,0xEC,0x38,0x50,0xF1,0x77,0x48,0x99,0xB3,0xEA,0x4C,0xFE,0x25,0x74,0x6D,0x0C,0x16,0xCB,0xCC,0xC8,0x8E,0x20,0xE8,0x24,0xCC,0xCA,0xFF,0xC4,0x26,0x41,0x18,0xE1,0xEF,0x6A,0xBD,0x06,0xF6,0x4A,0x5B,0xBD,0x2A,0x6E,0xE4,0x67,0x1F,0x1B,0x48,0xA4,0x65,0x13,0x11,0x38,0x9B,0xD4,0x46,0x18,0xFB,0x7A,0xFF,0x13};
    uint8_t ID[16]={0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38};
    uint8_t message[13]={0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd};
    uint16_t message_len=13,IDlen=16;
    uint8_t sig[64];
    uint8_t rand[32]={0xA0,0x1C,0x91,0xD1,0x2B,0x02,0x3E,0x5E,0x90,0x7D,0x1A,0x9B,0x72,0xA6,0x92,0x59,0x63,0x17,0xD7,0xA4,0x49,0x00,0xB1,0x85,0x6C,0x7E,0xB4,0x66,0xD5,0xC9,0x0F,0xA1};
    ECC_preprocess_randomnum(rand);
    ECC_sign(prikey, ID,  IDlen,  message, message_len,  sig,  ECC_CURVE_SM2_STANDARD|mask);
    ret=ECC_verify( pubkey,  ID,  IDlen,  message,  message_len,  sig,  ECC_CURVE_SM2_STANDARD |mask);
    if(ret==SUCCESS)
    {
        printf("Sm2 verify success\n");
    }
    else
    {
        printf("Sm2 verify fail\n");
    }
#endif
#if 0
    uint16_t ret=0x1122;
    uint8_t prikey[32]={0xCE,0x85,0x29,0x74,0x01,0xED,0x27,0xCA,0x4B,0xD1,0x4F,0xFB,0xE6,0xF2,0x9B,0x31,0x6C,0x84,0x2E,0x42,0x7F,0x70,0x2B,0x5D,0x97,0x42,0x56,0x93,0x4B,0x20,0x54,0x88};
    uint8_t pubkey[64]={0xFC,0xA2,0x33,0xD4,0x55,0xC4,0x6C,0xAF,0x2F,0xFF,0x93,0x08,0x7D,0x92,0xF8,0x0E,0x18,0xC8,0x3E,0x59,0x82,0x83,0x9F,0x18,0x13,0xCB,0xAC,0x56,0xBF,0x82,0x05,0x3A,0xD1,0x1F,0x79,0xCE,0xBF,0xF6,0xD1,0x26,0x45,0x89,0xD9,0x9C,0xC3,0xB9,0xE7,0x48,0xF1,0x9C,0xBD,0x9A,0x84,0xC9,0x3D,0x13,0x05,0x0C,0xD9,0xB1,0x40,0xFF,0x67,0xB2};
    uint8_t message[13]={0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd};
    uint16_t message_len=13;
    uint8_t sig[64];
    uint8_t rand[32]={0xA0,0x1C,0x91,0xD1,0x2B,0x02,0x3E,0x5E,0x90,0x7D,0x1A,0x9B,0x72,0xA6,0x92,0x59,0x63,0x17,0xD7,0xA4,0x49,0x00,0xB1,0x85,0x6C,0x7E,0xB4,0x66,0xD5,0xC9,0x0F,0xA1};
    ECC_preprocess_randomnum(rand);
    ECC_sign(prikey, NULL, 0, message, message_len,  sig, ECC_CURVE_SECP256K1|mask);
    ret=ECC_verify(pubkey,  NULL,  0,  message,  message_len,  sig,  ECC_CURVE_SECP256K1);
    if(ret==SUCCESS)
    {
        printf("SECP256K1 verify success\n");
    }
    else
    {
        printf("SECP256K1 verify fail\n");
    }
#endif
#if 0
    uint16_t ret=0x1122;
    uint8_t prikey[32]={0xCE,0x85,0x29,0x74,0x01,0xED,0x27,0xCA,0x4B,0xD1,0x4F,0xFB,0xE6,0xF2,0x9B,0x31,0x6C,0x84,0x2E,0x42,0x7F,0x70,0x2B,0x5D,0x97,0x42,0x56,0x93,0x4B,0x20,0x54,0x88};
    uint8_t pubkey[64]={0xF4,0x34,0x8D,0x92,0xD8,0xA1,0x7D,0x37,0xEF,0xB6,0xD3,0x07,0xA3,0x00,0x38,0x21,0x4C,0xDB,0x10,0x78,0xB7,0x23,0x84,0xD9,0xF5,0x2E,0x96,0xBC,0xFE,0x24,0xDC,0xB3,0x5C,0x85,0xE8,0x12,0x2D,0xFE,0x16,0xFA,0xF6,0xBC,0xD4,0xBB,0x3C,0xFE,0xB7,0xF0,0x98,0xE4,0xB9,0x23,0x7B,0x79,0xF3,0xD8,0xD1,0xF7,0x1D,0xC3,0x49,0xE5,0x9E,0xFF};
    uint8_t message[13]={0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd};
    uint16_t message_len=13;
    uint8_t sig[64];
    uint8_t rand[32]={0xA0,0x1C,0x91,0xD1,0x2B,0x02,0x3E,0x5E,0x90,0x7D,0x1A,0x9B,0x72,0xA6,0x92,0x59,0x63,0x17,0xD7,0xA4,0x49,0x00,0xB1,0x85,0x6C,0x7E,0xB4,0x66,0xD5,0xC9,0x0F,0xA1};
    ECC_preprocess_randomnum(rand);
    ECC_sign(prikey, NULL, 0, message, message_len,  sig, ECC_CURVE_SECP256R1|mask);
    ret=ECC_verify(pubkey,  NULL,  0,  message,  message_len,  sig,  ECC_CURVE_SECP256R1|mask);
    
    if(ret==SUCCESS)
    {
        printf("SECP256R1 verify success\n");
    }
    else
    {
        printf("SECP256R1 verify fail\n");
    }
#endif
#if 0
    uint32_t mask1=1<<8,mask2=1<<9;
    uint8_t a=0;
    extern void HMAC_RFC6979_init(HMAC_RFC6979 *ctx,uint8_t * key,uint16_t key_len);
    extern void HMAC_RFC6979_gnerate(HMAC_RFC6979 *ctx,uint8_t * out,uint16_t outlen);
    extern int nonce_function_rfc6979(uint8_t *nonce,uint8_t *msg,uint8_t *key,uint8_t *algo,void *data,uint32_t counter);
   uint8_t msg[32]={0xA4,0x4C,0x69,0x32,0x00,0xC3,0x7B,0x00,0x32,0x68,0x76,0x27,0x17,0x6E,0x41,0xDF,0xAC,0xC9,0x53,0xCC,0x77,0xEB,0x97,0x63,0x81,0xCD,0xB7,0xA6,0x6B,0x17,0x21,0x58};
    uint8_t key[32]={0xBC,0xB9,0x71,0xDD,0x9A,0x73,0x1B,0x66,0xA4,0x25,0x51,0x7F,0x1F,0x02,0xC8,0xC3,0xAF,0x46,0xAF,0x74,0xFF,0x2F,0x62,0xF4,0xEF,0x21,0x14,0x70,0x41,0xC6,0xBB,0xA5};
   // uint8_t key[64]={0xA4,0x4C,0x69,0x32,0x00,0xC3,0x7B,0x00,0x32,0x68,0x76,0x27,0x17,0x6E,0x41,0xDF,0xAC,0xC9,0x53,0xCC,0x77,0xEB,0x97,0x63,0x81,0xCD,0xB7,0xA6,0x6B,0x17,0x21,0x58,0xBC,0xB9,0x71,0xDD,0x9A,0x73,0x1B,0x66,0xA4,0x25,0x51,0x7F,0x1F,0x02,0xC8,0xC3,0xAF,0x46,0xAF,0x74,0xFF,0x2F,0x62,0xF4,0xEF,0x21,0x14,0x70,0x41,0xC6,0xBB,0xA5};
    uint8_t nonce[32];
    uint8_t out[32];
    uint8_t sig[65];
    HMAC_RFC6979 ctx;
    //HMAC_RFC6979_init(&ctx, key,42);
    //HMAC_RFC6979_gnerate(&ctx, out,32);
    nonce_function_rfc6979(nonce, msg, key,NULL,NULL,0);
    //ECC_preprocess_randomnum(nonce);
    //ECC_sign( key, NULL, 0, msg, 32,  sig,  ECC_CURVE_SECP256K1 | mask1|mask2);
    a++;
#endif
    uint8_t a=0;
    uint8_t msg[16]={0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x30,0x61,0x62,0x63,0x64,0x65,0x66};
    uint16_t msg_len=16;
    uint8_t digest[32];
    //sha3_256_hash(msg, msg_len, digest);
    hash(msg, msg_len, digest, 0, HASH_ALG_SHA3_256);
    a++;
}



/*
 @function:construct a message authentication code and a secret key
 @paramter[in]msg pointer to input message
 @paramter[in]msg_len is the byte length of message
 @note:according to RFC6979 procedure
*/

void HMAC_RFC6979_init(HMAC_RFC6979 *ctx,uint8_t * key,uint16_t keylen)
{
    uint8_t *tempbuf=NULL;
    //V=calloc(32,sizeof(uint8_t));
   //K=calloc(32,sizeof(uint8_t));
    tempbuf=calloc(33+keylen,sizeof(uint8_t));
    //step b
    memset(ctx->v,0x01,32);
    //step c
    memset(ctx->k,0x00,32);
    //step d
    memcpy(tempbuf,ctx->v,32);
    memset(tempbuf+32,0,1);
    memcpy(tempbuf + 33,key,keylen);
    HMAC(ctx->k, 32, tempbuf,33 +keylen, ctx->k, HMAC_SHA256_ALG);
    //step e
    HMAC(ctx->k, 32, ctx->v,32, ctx->v, HMAC_SHA256_ALG);
    //step f
    memcpy(tempbuf,ctx->v,32);
    memset(tempbuf+32,0x01,1);
    HMAC(ctx->k, 32, tempbuf,33+keylen, ctx->k, HMAC_SHA256_ALG);
    //step g
    HMAC(ctx->k, 32, ctx->v,32, ctx->v, HMAC_SHA256_ALG);
    ctx->retry=0;
}

void HMAC_RFC6979_gnerate(HMAC_RFC6979 *ctx,uint8_t * out,uint16_t outlen)
{
    uint8_t *tempbuf=NULL;
    memset(out,0,outlen);
    if(ctx->retry)
    {
        tempbuf=calloc(33,sizeof(uint8_t));
        memcpy(tempbuf,ctx->v,32);
        memset(tempbuf+32, 0, 1);
        HMAC(ctx->k, 32, tempbuf,33, ctx->k, HMAC_SHA256_ALG);
        HMAC(ctx->k, 32, ctx->v,32, ctx->v, HMAC_SHA256_ALG);
    }
    while(outlen>0){
        HMAC(ctx->k, 32, ctx->v,32, ctx->v, HMAC_SHA256_ALG);
        memcpy(out,ctx->v,32);
        out += 32;
        outlen -= 32;
    }
    ctx->retry=1;
}

void HMAC_RFC6979_finalize(HMAC_RFC6979 *ctx)
{
    memset(ctx->k,0,32);
    memset(ctx->k,0,32);
    ctx->retry=0;
}

/*
 @paramter[in]msg pointer to message(32 byte)
 @paramter[in]key pointer to private key(32 byte)
 @paramter[in]algo16 pointer to algorithm name(16 byte)
 @paramter[in]data pointer to optionally extra bytes of data(32 byte)
 */
 int nonce_function_rfc6979(uint8_t *nonce,uint8_t *msg,uint8_t *key,uint8_t *algo,void *data,uint32_t counter)
{
    uint8_t keydata[112];
    HMAC_RFC6979 ctx;
    int keylen=64,i;
    memcpy(keydata, key, 32);
    memcpy(keydata + 32,msg,32);
    if(data !=NULL)
    {
        memcpy(keydata + 64,data,32);
        keylen +=32;
    }
    if(algo != NULL)
    {
        memcpy(keydata +keylen, algo, 16);
        keylen +=16;
    }
    HMAC_RFC6979_init(&ctx,  keydata,keylen);
    for(i=0;i<counter;i++)
    {
        HMAC_RFC6979_gnerate(&ctx,nonce, 32);
    }
    HMAC_RFC6979_finalize(&ctx);
    return 0;
}

